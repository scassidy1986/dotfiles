#!/usr/bin/env sh

set -e

DEFAULT_NAMESPACE="kube-system"
SCRIPT_NAME=${0##*/}

function banner () {
  echo "========================================================================="
}

function usage () {
  echo "Usage: ${SCRIPT_NAME} -s <secret> -n <namespace>"
  echo "   -s --secret      the secret to retrieve. Partial secret names will return all matching tokens"
  echo "   -l --list        list all possible secrets and tokens"
  echo "   -n --namespace   the namespace to search. Defaults to ${DEFAULT_NAMESPACE}"
  echo "   -k --kubeconfig  the kube config to use. Defaults to the environment variable 'KUBECONFIG'"
}

list="0"
secret=""
namespace=${DEFAULT_NAMESPACE}

SHORTOPTS="s:n:k:lh"
LONGOPTS="secret:,namespace:,kubeconfig:,list,help"
ARGS=$(getopt -s bash --options "${SHORTOPTS}" --longoptions "${LONGOPTS}" --name "${SCRIPT_NAME}" -- "$@" )

eval set -- "${ARGS}"
while true; do
  case $1 in
    -s|--secret)  
      shift
      secret="${1}"
      ;;
    -n|--namespace)  
      shift
      namespace="${1}"
      ;;
    -k|--kubeconfig)
      shift
      export KUBECONFIG="${1}"
      ;;
    -l|--list)
      list="1"
      ;;
    -h|--help)  
      usage
      exit 0
      ;;
    --)
      shift
      break
      ;;
    *)  
      shift
      break
      ;;
  esac
  shift
done

if [[ -z "${namespace}" || -z "${KUBECONFIG}" ]]; then
  echo "Missing required parameters:"
  echo "> -n         namespace      [${namespace}]"
  echo "> -k         kubectl config [${KUBECONFIG}]"
  usage
  exit 1
fi

echo "Attempting to retrieve the following from kubernetes using kubectl config [${KUBECONFIG}]:"
echo "> secret    ${secret}"
echo "> namespace ${namespace}"

json=$(kubectl get secrets -n ${namespace} -o json)
result=""
if [[ "${list}" == "1" ]]; then
    echo "list"
  result=$(echo "${json}" | jq -r '.items[] | select(.metadata.name) | [.metadata.name, .data.token] | @tsv')
else
    echo "no list"
  result=$(echo "${json}" | jq -r --arg VAL "${secret}" '.items[] | select(.metadata.name | contains($VAL)) | [.metadata.name, .data.token] | @tsv')
fi

echo "${result}" | while IFS=$'\t' read -r name token; do
  if [[ ! -z "${token}" ]]; then
    echo
    echo
    echo "${name}"
    banner
    echo "\"$(echo ${token} | base64 --decode)\""
    banner
  fi
done

echo "Done!"

exit 0
